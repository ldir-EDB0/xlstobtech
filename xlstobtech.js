#!/usr/bin/env node

// inspired by script written by Bridgetech that did one csv file

// Extensively modified, mangled and extended by Kevin Darbyshire-Bryant
// with significant aid from ChatGPT & Copilot (I don't know javascript!)

// the probe supports update and delete modes which use a tuningID for working out
// if channels are new or existing.  tuningIDs are generated by the probe when the
// channel is created, so we can't generate them here.
// not specifying a mode will erase all existing channels and replace them with the new ones
// no mode is the default and what we have been doing so far.
// it would be nice to be able to add new channels without deleting existing ones,
// update existing channels if they have changed in the source sheet
// and delete channels that are listed in a sheet, ie remove a previously added sheet
//
// this suggests we need to support four modes:
// load (overwrite), add, update and delete
// update & delete modes will require pulling the existing channels from the probe first
// and then processing the sheet to determine which channels to update or delete

const fs = require('fs');
const path = require('path');
const xlsx = require('xlsx');
const ip = require('ip');
const { XMLParser, XMLBuilder } = require('fast-xml-parser');

// Parse command line arguments
// Returns an object with inputFile, outputDir, pushProbe, pushSheet, and pushMode
function parseArgs() {
  const args = process.argv.slice(2);
  let inputFile;
  let outputDir = 'btechxml';
  let pushProbe = '';
  let pushSheet = '';
  let pushMode = '';

  for (let i = 0; i < args.length; i++) {
    if (args[i] === '-x' && i + 1 < args.length) {
      inputFile = args[i + 1];
      i++;
    } else if (args[i] === '-d' && i + 1 < args.length) {
      outputDir = args[i + 1];
      i++;
    } else if (args[i] === '-p' && i + 1 < args.length) {
      pushProbe = args[i + 1];
      i++;
    } else if (args[i] === '-s' && i + 1 < args.length) {
      pushSheet = args[i + 1];
      i++;
    } else if (args[i] === '-a') {
      pushMode = 'add';
    } else if (args[i] === '-u') {
      pushMode = 'update';
    } else if (args[i] === '-r') {
      pushMode = 'delete';
    }
  }
  if (!inputFile || (Boolean(pushProbe) !== Boolean(pushSheet))) {
    console.log(`
Usage:
  node xlstobtech.js -x <input.xls> [ [-d <output-folder>] || -p <probe> -s <sheet> ]

Options:
  -x <file>      Excel file to process (required)

  -d <folder>    Output directory (optional, defaults to btechxml)
or
  -s <sheet>     Specify sheet to push
  -p <probe>     Push specified sheet to probe

  Examples:
  node xlstobtech.js -x input.xlsx
  node xlstobtech.js -x input.xls -d ./configs
`);
    process.exit(0);
  }

  console.log(`Input XLS: ${inputFile}`);
  console.log(`Output directory: ${outputDir}`);
  
  return { inputFile, outputDir, pushProbe, pushSheet, pushMode };
}

// fetch and parse the probe's current multicast channels
// returns a dictionary of channels by name, or null if none found
async function fetchAndStoreMcastChannels(xmlUrl) {
  const mcastChannelsByName = {};

  try {
//    const xmlText = fs.readFileSync('/Users/kevin/Downloads/eth_streamlist_ex.xml', 'utf8'); //read from file whilst testing

    const response = await fetch(xmlUrl);
    const xmlText = await response.text();

    const parser = new XMLParser({
      ignoreAttributes: false, // Needed to retain @name, @tuningId, etc.
      attributeNamePrefix: "@_",
      parseAttributeValue: true, // Parse attributes as their original types
    });
    const parsed = parser.parse(xmlText);

    // Navigate to mcastChannel list
    const channels =
      parsed?.ewe?.probe?.core?.setup?.mcastnames?.mclist?.mcastChannel;
    if (!channels) {
      throw new Error("No mcastChannel elements found.");
    }

    // Ensure it's always an array
    const channelList = Array.isArray(channels) ? channels : [channels];

    for (let channel of channelList) {
      const name = channel?.["@_name"];
      if (name) {
        mcastChannelsByName[name] = {
          tuningId: channel["@_tuningId"],
          addr: channel["@_addr"],
          port: channel["@_port"],
          joinIfaceName: channel["@_joinIfaceName"],
          ssmAddr: channel["@_ssmAddr"],
        };
      }
    }

    console.log("Channels loaded:", Object.keys(mcastChannelsByName).length);
  } catch (err) {
    console.error("Failed to fetch or parse XML:", err);
  }

  return Object.keys(mcastChannelsByName).length ? mcastChannelsByName : null;
}

/**
 * Parse the IPGW string like '192.168.219.1/24/.1' into its components:
 *  - Host IP address
 *  - Prefix length
 *  - Calculated Gateway IP address - validates that the host and gateway are in the same /24 subnet
 * returns an object with hostIP, prefix, and gatewayIP.
 */
function parseIPGW(input) {
  if (!input || !input.includes('/') || !input.includes('.')) {
    return { hostIP: '', prefix: '', gatewayIP: '' };
  }

  const match = input.match(/^(.+?)\/(\d{1,2})\/(\.\d+)$/);
  if (!match) return { hostIP: '', prefix: '', gatewayIP: '' };

  const [_, hostIP, prefixStr, suffixStr] = match;
  const prefix = parseInt(prefixStr, 10);
  if (!ip.isV4Format(hostIP) || isNaN(prefix) || prefix < 24 || prefix > 32) {
    return { hostIP: '', prefix: '', gatewayIP: '' };
  }

  const hostParts = hostIP.split('.');
  const suffix = suffixStr.slice(1); // '.129' ‚Üí '129'

  const gatewayIP = `${hostParts[0]}.${hostParts[1]}.${hostParts[2]}.${suffix}`;

  if (!ip.isV4Format(gatewayIP)) return { hostIP: '', prefix: '', gatewayIP: '' };

  // Sanity check: host and gateway must be in the same /24
  if (hostParts.slice(0, 3).join('.') !== gatewayIP.split('.').slice(0, 3).join('.')) {
    return { hostIP: '', prefix: '', gatewayIP: '' };
  }

  return {
    hostIP,
    prefix,
    gatewayIP,
  };
}


// Process unicast sheet and extract interface data
// return a list of probe friendly names and a 
// dictionary of interfaces by friendly name and VLAN
// we need the IP address of the DTV interface to push the config to the probe
function processUnicastSheet(workbook) {
  const sheet = workbook.Sheets['unicast'];
  if (!sheet) throw new Error('‚ö†Ô∏è  Error: "unicast" sheet not found');

  let json = xlsx.utils.sheet_to_json(sheet, { defval: '' });
  if (json.length === 0) throw new Error('‚ö†Ô∏è  Error: "unicast" sheet is empty');

  const probeNames = [];
  const interfaceByNameVlan = {};

  for (const row of json) {
    const Name = row['FRIENDLY_NAME'];
    if (!Name) continue;

    const Vlan = row['VLAN'] ? row['VLAN'].toString().toLowerCase() : '';
    const Interface = row['INTERFACE'];
    const {hostIP, prefix, gatewayIP} = parseIPGW(row['IP_PRFX_GW']);

    if (!hostIP || !prefix || !gatewayIP) {
      console.warn(`‚ö†Ô∏è  Invalid IP/Prefix/Gateway for ${Name} (${Vlan}) address "${row['IP_PRFX_GW']}", skipping...`);
      continue;
    } 

    if (Name && !probeNames.includes(Name)) probeNames.push(Name);

    if (Name && Interface) {
      const key = `${Name}-${Vlan}`;
      if (!interfaceByNameVlan[key]) {
        interfaceByNameVlan[key] = {
          Interface,
          hostIP,
          prefix,
          gatewayIP
        };
      }
    }
  }

  console.log(`Found ${probeNames.length} Probes in unicast sheet`);
  return { probeNames, interfaceByNameVlan };
}

// Process profiles sheet
// return a dictionary of audio/video profiles from the profiles sheet
// assume reasonable defaults for sample rate, audio depth, channel order, and ports
function processProfilesSheet(workbook) {
  const sheet = workbook.Sheets['profiles'];
  if (!sheet) throw new Error('‚ö†Ô∏è  Error: "profiles" sheet not found, I need some data from it.');
  
  const json = xlsx.utils.sheet_to_json(sheet, { defval: '' });
  if (json.length === 0) throw new Error('‚ö†Ô∏è  Error: "profiles" sheet is empty, I need some data from it.');

  const profiles = {};
  
  for (const row of json) {
    const profile = row['profile'];
    if (profile) {
      profiles[profile] = {
        profile,
        content: row['content'] || '',
        audiodepth: row['audiodepth'] || '24',
        channelorder: row['channelorder'] || 'ST',
        audiosr: row['audiosr'] || '48000',
        port_no_a: row['port_no_a'] || '5004',
        port_no_b: row['port_no_b'] || '5004',
      };
    }
  }
  
  console.log(`Found ${Object.keys(profiles).length} profiles in profiles sheet`);
  return profiles;
}

// Build multicast channel object from the passed parameters
// referencing the profile for audio depth, sample rate, and channel order
function buildMcastChannel(name, source_ip, multicast, port, iface, profile, groups, page, join) {
  return {
    name: name,
    addr: multicast,
    port: port,
    sessionId: "0",
    groups: groups,
    audiodepth: profile.audiodepth,
    audiosr: profile.audiosr,
    channelOrder: profile.channelorder,
    joinIfaceName: iface,
    ssmAddr: source_ip,
    join: join,
    page: page,
    etrEngine: "1",
    extractThumbs: true,
    enableFec: false,
    enableRtcp: true
  };
}

// Process individual sheet and generate multicasts
// returns an array of multicast channel objects for designated probe
function processSheet(workbook, sheetName, probe, interfaceByNameVlan, profiles) {
  console.log(`üîÑ Processing sheet: ${sheetName}`);
  const sheet = workbook.Sheets[sheetName];
  const json = xlsx.utils.sheet_to_json(sheet, { defval: '' });

  if (json.length === 0) {
    console.warn(`‚ö†Ô∏è  Skipping empty sheet: ${sheetName}`);
    return null;
  }

  const multicasts = [];
  let skipped = 0;

  for (const row of json) {
    const groups = row['groups'] || '';
    const page = row['page'] || '1';
    const name = row['name'] || '';
    const device = row['device'] || '';
    const join = (row['join'] && row['join'].toString().trim().toLowerCase() === 'no') ? false : true;
    const profileName = row['profile'] || '';
    const source_ip_a = row['source_ip_a'] || '';
    const multicast_a = row['multicast_a'] || '';
    const vlan_a = row['vlan_a'] || 'dff-a';
    const source_ip_b = row['source_ip_b'] || '';
    const multicast_b = row['multicast_b'] || '';
    const vlan_b = row['vlan_b'] || 'dff-b';

    // Lookup profile data
    const profile = profiles[profileName] || {};
  
    // Get probe interface name for VLAN
    const iface_a = interfaceByNameVlan[`${probe}-${vlan_a}`];
    const iface_b = interfaceByNameVlan[`${probe}-${vlan_b}`];

    //A leg
    if (iface_a && source_ip_a && multicast_a) {
      const mname = source_ip_b ? `${name}@A` : `${name}`;

      multicasts.push(buildMcastChannel(mname, source_ip_a, multicast_a, profile.port_no_a, iface_a.Interface, profile, groups, page, join));
    }

    //B leg
    if (iface_b && source_ip_b && multicast_b) {
      const mname = source_ip_a ? `${name}@B` : `${name}`;

      multicasts.push(buildMcastChannel(mname, source_ip_b, multicast_b, profile.port_no_b, iface_b.Interface, profile, groups, page, join));
    }

    if ((!multicast_a && !multicast_b) || (!source_ip_a && !source_ip_b)) {
      skipped++;
      continue;
    }
  }

  console.log(`‚úÖ Sheet "${sheetName}": ${multicasts.length} entries (skipped ${skipped})`);
  return multicasts.length ? multicasts : null;
}

// write XML config for BTech probe
// returns a string of XML containing the multicast channels
// suitable for sending to the probe
function wrapXml(multicasts) {
  const builder = new XMLBuilder({
    ignoreAttributes: false,
    format: true,
    indentBy: '  ',
    suppressBooleanAttributes: false, // you have no idea how long it took to find this option!
  });

  const obj = {
    '?xml': {
      '@_version': '1.0',
    },
    ewe: {
      probe: {
        core: {
          setup: {
            mcastnames: {
              mclist: {
                '@_xmlChildren': 'list',
                mcastChannel: multicasts.map(mc => {
                  const attrs = {};
                  for (const [key, value] of Object.entries(mc)) {
                    attrs[`@_${key}`] = String(value);
                  }
                  return attrs;
                })
              }
            }
          }
        }
      }
    }
  };

  return builder.build(obj);
}


// Write output xml file
// use wrapXml to generate the XML string
// and write it to a file in the specified output directory
function writeConfigFile(outputDir, probe, sheetName, multicasts) {

  const btechxml = wrapXml(multicasts);
  const safeSheetName = sheetName.replace(/[ \\/:*?"<>|]/g, '_');
  const safeprobe = probe.replace(/[ \\/:*?"<>|]/g, '_');
  const probeoutputDir = path.join(outputDir, safeprobe);
  fs.mkdirSync(probeoutputDir, { recursive: true });
  const outputPath = path.join(probeoutputDir, `${safeSheetName}.xml`);

  fs.writeFileSync(outputPath, btechxml);
  console.log(`üíæ Written: ${outputPath}`);
}

// Get the URL for the probe's import/export endpoint
// returns a URL object or null if the interface is not found
// the dtv interface is used for pushing config to the probe
function getProbeUrl(interfaceByNameVlan, probe, pushMode) {
  const iface = interfaceByNameVlan[`${probe}-dtv`];
  if (!iface) {
    console.error(`‚ùå Error: DTV Interface for probe "${probe}" not found.`);
    return null;
  }
  if (!iface.hostIP) {
    console.error(`‚ùå Error: Host IP for probe "${probe}" is not defined.`);
    return null;
  }
  return new URL(pushMode ? `http://${iface.hostIP}/probe/core/importExport/data.xml?mode=${pushMode}`
    : `http://${iface.hostIP}/probe/core/importExport/data.xml`);
}

// Push config to specified probe
// get the URL for the probe's import/export endpoint, generate the XML from multicasts
// and POST it to the probe
async function pushConfig(interfaceByNameVlan, probe, sheetName, pushMode, multicasts) {

  const probeUrl = getProbeUrl(interfaceByNameVlan, probe, pushMode);
  if (!probeUrl) return;

  const btechxml = wrapXml(multicasts);

  console.log(`üì§ Pushing config for ${sheetName} to probe ${probe} using URL ${probeUrl}`);

  try {
    const res = await fetch(probeUrl, {
       method: 'POST',
       headers: { 'Content-Type': 'application/xml' },
       body: btechxml,
    });

    if (!res.ok) {
      const errorText = await res.text();
      throw new Error(`HTTP ${res.status}: ${errorText}`);
    }

    console.log(`‚úÖ Successfully uploaded XML to ${probe}`);
  } catch (postErr) {
    console.error(`‚ùå Failed to POST to ${probe}:`, postErr.message);
  }
}

// Process all sheets in the workbook
// for each probe, and for each multicast sheet, generate a config file
// and write it to the output directory
function ProcessAllSheets(workbook, sheetNames, Probes, interfaceByNameVlan, profiles, outputDir) {

  // create base output directory if it doesn't exist
  fs.mkdirSync(outputDir, { recursive: true });

  for (const sheetName of sheetNames) {
    for (const probe of Probes) {
      const multicasts = processSheet(workbook, sheetName, probe, interfaceByNameVlan, profiles);
      if (multicasts) writeConfigFile(outputDir, probe, sheetName, multicasts);
    }
  }
}

// in progress this one
async function updelConfig(interfaceByNameVlan, probe, sheetName, pushMode, multicasts) {
  const probeUrl = getProbeUrl(interfaceByNameVlan, probe, '');
  if (!probeUrl) return;

  const currentChannelsByName = await fetchAndStoreMcastChannels(probeUrl.href);

  if (pushMode === 'delete' && currentChannelsByName) {
    // remove channels that are in the sheet and in the current channels
    // determine matching channels by multicast name
    // if the name is in the current channel then use the tuningId to delete it
    const toDelete = [];
    for (const mc of multicasts) {
      const current = currentChannelsByName[mc.name];
      if (current && current.tuningId) {
        toDelete.push({ tuningId: current.tuningId });
      }
    }

    if (toDelete.length > 0) {
      console.log(`üîÑ Deleting ${toDelete.length} channels from probe ${probe}...`);
      await pushConfig(interfaceByNameVlan, pushProbe, pushSheet, pushMode, toDelete);
      
    } else {
      console.log(`No channels to delete for probe ${probe}.`);
    }
  }

}

// Main function
async function main() {
  const skipSheets = new Set(['unicast', 'profiles', 'validation']);

  try {
    const { inputFile, outputDir, pushProbe, pushSheet, pushMode } = parseArgs();

    console.log(`Reading Excel file...`);
    const workbook = xlsx.readFile(inputFile);
    // Exclude sheets in skipSheets from sheetNames
    const sheetNames = workbook.SheetNames.filter(name => !skipSheets.has(name));
    if (sheetNames.length === 0) throw new Error('No valid sheets to process in Excel file.'); // any left?

    //get the probe names and their interfaces from the unicast sheet
    const { probeNames: Probes, interfaceByNameVlan } = processUnicastSheet(workbook);

    //get audio/video profiles from the profiles sheet
    const profiles = processProfilesSheet(workbook);

    // If pushProbe and pushSheet are specified, process only that sheet for the probe
    if (pushProbe && pushSheet) {
      if (!Probes.includes(pushProbe)) {
        console.error(`‚ùå Error: Probe "${pushProbe}" not found in unicast sheet.`);
      }
      if (skipSheets.has(pushSheet)) {
        console.error(`‚ùå Error: Sheet "${pushSheet}" is not a pushable sheet.`);
      }
      else if (!sheetNames.includes(pushSheet)) {
        console.error(`‚ùå Error: Sheet "${pushSheet}" not found in the workbook.`);
      }

      const multicasts = processSheet(workbook, pushSheet, pushProbe, interfaceByNameVlan, profiles);
      if (!multicasts || multicasts.length === 0) {
        console.warn(`‚ö†Ô∏è  No valid multicasts found in sheet "${pushSheet}" for probe "${pushProbe}".`);
      } else {
        if (pushMode === 'add') {
          console.log(`üîÑ Pushing add mode for sheet "${pushSheet}" to probe "${pushProbe}"...`);
          if (multicasts) await pushConfig(interfaceByNameVlan, pushProbe, pushSheet, 'update', multicasts);
          console.log(`üéâ Processed ${pushSheet} for probe ${pushProbe}.`);
        } else if (pushMode === 'update' || pushMode === 'delete') {
          console.log(`üîÑ Pushing ${pushMode} mode for sheet "${pushSheet}" to probe "${pushProbe}" not yet supported...`);
          if (multicasts) await updelConfig(interfaceByNameVlan, pushProbe, pushSheet, pushMode, multicasts);
          console.log(`üéâ Processed ${pushSheet} for probe ${pushProbe}.`);
        } else {
          // Default: overwrite (load)
          console.log(`üîÑ Pushing overwrite (load) mode for sheet "${pushSheet}" to probe "${pushProbe}"...`);
          if (multicasts) await pushConfig(interfaceByNameVlan, pushProbe, pushSheet, '', multicasts);
          console.log(`üéâ Processed ${pushSheet} for probe ${pushProbe}.`);
        }
      }
    } else { // Process all sheets for all probes
      ProcessAllSheets(workbook, sheetNames, Probes, interfaceByNameVlan, profiles, outputDir);
      console.log(`üéâ All sheets processed.`);
    }
  } catch (err) {
    console.error('‚ùå Error:', err.message);
    process.exit(1);
  }
}

// Execute the program
main();
